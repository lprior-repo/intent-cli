/// Bead CUE Generation
/// Generates beads as CUE files matching schema/beads.cue #Bead type
///
/// Option B Architecture:
/// - Session file: .intent/session-{id}.cue (interview + beads)
/// - Feedback file: .intent/feedback-{id}.cue (append execution results)
/// - CUE unifies these automatically: cue export .intent/*-{id}.cue
import gleam/int
import gleam/list
import gleam/string

// =============================================================================
// TYPES: Matching schema/beads.cue
// =============================================================================

/// A single work item (bead) - atomic unit of work (5-30 min)
pub type Bead {
  Bead(
    id: String,
    // Format: PREFIX-NNN (e.g., AUTH-001)
    title: String,
    what: String,
    // Imperative, actionable
    why: String,
    // Business value, user impact
    test_spec: TestSpec,
    // Named test_spec to avoid reserved word
    done_when: List(String),
    file: String,
    // Primary file to modify
    edge_cases: List(String),
    requires: List(String),
    // Dependencies (bead IDs)
    effort: String,
    // "5min" | "10min" | "15min" | "20min" | "30min"
    status: String,
    // "pending" | "in_progress" | "blocked" | "completed" | "failed"
  )
}

/// Test specification for verifying bead completion
pub type TestSpec {
  TestSpec(command: String, expect: Expectation)
}

/// Expected outcomes for test verification
pub type Expectation {
  Expectation(
    exit_code: Int,
    stdout_contains: String,
    stdout_matches: String,
    // regex
    stderr_empty: Bool,
    status: Int,
    // HTTP status
    body_contains: String,
    header_present: String,
  )
}

/// Bead feedback - execution result
pub type BeadFeedback {
  BeadFeedback(
    bead_id: String,
    result: String,
    // "success" | "failed" | "blocked" | "skipped"
    reason: String,
    executed_at: String,
    duration_ms: Int,
    error_type: String,
    error_message: String,
    error_trace: String,
  )
}

// =============================================================================
// BEAD ID GENERATION
// =============================================================================

/// Generate bead ID in PREFIX-NNN format
pub fn generate_bead_id(prefix: String, number: Int) -> String {
  let padded = case number {
    n if n < 10 -> "00" <> int.to_string(n)
    n if n < 100 -> "0" <> int.to_string(n)
    n -> int.to_string(n)
  }
  prefix <> "-" <> padded
}

// =============================================================================
// BEAD TO CUE CONVERSION
// =============================================================================

/// Convert a single bead to CUE format
pub fn bead_to_cue(bead: Bead) -> String {
  "{\n"
  <> "\tid: \""
  <> bead.id
  <> "\"\n"
  <> "\ttitle: \""
  <> escape_cue_string(bead.title)
  <> "\"\n"
  <> "\twhat: \""
  <> escape_cue_string(bead.what)
  <> "\"\n"
  <> "\twhy: \""
  <> escape_cue_string(bead.why)
  <> "\"\n"
  <> test_spec_to_cue(bead.test_spec)
  <> "\tdone_when: "
  <> string_list_to_cue(bead.done_when)
  <> "\n"
  <> "\tfile: \""
  <> bead.file
  <> "\"\n"
  <> "\tedge_cases: "
  <> string_list_to_cue(bead.edge_cases)
  <> "\n"
  <> "\trequires: "
  <> string_list_to_cue(bead.requires)
  <> "\n"
  <> "\teffort: \""
  <> bead.effort
  <> "\"\n"
  <> "\tstatus: \""
  <> bead.status
  <> "\"\n"
  <> "}"
}

/// Convert multiple beads to session CUE format
pub fn beads_to_cue(session_id: String, beads: List(Bead)) -> String {
  let beads_cue =
    list.map(beads, bead_to_cue)
    |> string.join(",\n")

  "// Beads for session: "
  <> session_id
  <> "\n"
  <> "// Generated by Intent CLI\n\n"
  <> "package intent\n\n"
  <> "beads: [\n"
  <> indent_lines(beads_cue, "\t")
  <> "\n]\n"
}

/// Convert test spec to CUE
fn test_spec_to_cue(spec: TestSpec) -> String {
  "\ttest: {\n"
  <> "\t\tcommand: \""
  <> escape_cue_string(spec.command)
  <> "\"\n"
  <> "\t\texpect: {\n"
  <> expectation_to_cue(spec.expect)
  <> "\t\t}\n"
  <> "\t}\n"
}

/// Convert expectation to CUE
fn expectation_to_cue(expect: Expectation) -> String {
  let parts = []

  // Only include non-empty/non-zero fields
  let parts = case expect.exit_code != 0 || True {
    True ->
      list.append(parts, [
        "\t\t\texit_code: " <> int.to_string(expect.exit_code),
      ])
    False -> parts
  }

  let parts = case string.length(expect.stdout_contains) > 0 {
    True ->
      list.append(parts, [
        "\t\t\tstdout_contains: \""
        <> escape_cue_string(expect.stdout_contains)
        <> "\"",
      ])
    False -> parts
  }

  let parts = case string.length(expect.stdout_matches) > 0 {
    True ->
      list.append(parts, [
        "\t\t\tstdout_matches: \""
        <> escape_cue_string(expect.stdout_matches)
        <> "\"",
      ])
    False -> parts
  }

  let parts = case expect.stderr_empty {
    True -> list.append(parts, ["\t\t\tstderr_empty: true"])
    False -> parts
  }

  let parts = case expect.status > 0 {
    True ->
      list.append(parts, ["\t\t\tstatus: " <> int.to_string(expect.status)])
    False -> parts
  }

  let parts = case string.length(expect.body_contains) > 0 {
    True ->
      list.append(parts, [
        "\t\t\tbody_contains: \""
        <> escape_cue_string(expect.body_contains)
        <> "\"",
      ])
    False -> parts
  }

  let parts = case string.length(expect.header_present) > 0 {
    True ->
      list.append(parts, [
        "\t\t\theader_present: \""
        <> escape_cue_string(expect.header_present)
        <> "\"",
      ])
    False -> parts
  }

  string.join(parts, "\n") <> "\n"
}

// =============================================================================
// BEAD FEEDBACK TO CUE
// =============================================================================

/// Convert bead feedback to CUE for appending to feedback file
pub fn feedback_to_cue(feedback: BeadFeedback) -> String {
  "session: feedback: [{\n"
  <> "\tbead_id: \""
  <> feedback.bead_id
  <> "\"\n"
  <> "\tresult: \""
  <> feedback.result
  <> "\"\n"
  <> "\treason: \""
  <> escape_cue_string(feedback.reason)
  <> "\"\n"
  <> "\texecuted_at: \""
  <> feedback.executed_at
  <> "\"\n"
  <> "\tduration_ms: "
  <> int.to_string(feedback.duration_ms)
  <> "\n"
  <> error_section_to_cue(feedback)
  <> "}]\n"
}

fn error_section_to_cue(feedback: BeadFeedback) -> String {
  case string.length(feedback.error_type) > 0 {
    True -> {
      "\terror: {\n"
      <> "\t\ttype: \""
      <> feedback.error_type
      <> "\"\n"
      <> "\t\tmessage: \""
      <> escape_cue_string(feedback.error_message)
      <> "\"\n"
      <> case string.length(feedback.error_trace) > 0 {
        True ->
          "\t\ttrace: \"" <> escape_cue_string(feedback.error_trace) <> "\"\n"
        False -> ""
      }
      <> "\t}\n"
    }
    False -> ""
  }
}

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

fn string_list_to_cue(items: List(String)) -> String {
  case items {
    [] -> "[]"
    _ -> {
      let quoted =
        list.map(items, fn(s) { "\"" <> escape_cue_string(s) <> "\"" })
      "[" <> string.join(quoted, ", ") <> "]"
    }
  }
}

fn escape_cue_string(s: String) -> String {
  s
  |> string.replace("\\", "\\\\")
  |> string.replace("\"", "\\\"")
  |> string.replace("\n", "\\n")
  |> string.replace("\t", "\\t")
}

fn indent_lines(text: String, indent: String) -> String {
  string.split(text, "\n")
  |> list.map(fn(line) { indent <> line })
  |> string.join("\n")
}
