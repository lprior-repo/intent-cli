#!/bin/bash
#
# TDD-TCR-REFACTOR Loop: Full Red-Green-Refactor with Architectural Oversight
#
# Four AI sessions with filesystem-enforced separation:
# - Auditor: writes tests (can't touch src/)
# - Implementer: writes code (can't touch test/) - with TCR enforcement
# - Architect: refactors after every N green cycles (ensures design quality)
# - Reviewer: final cleanup after completion
#
# The REFACTOR step is the key difference:
# - After every REFACTOR_INTERVAL successful implementations
# - Architect reviews and refactors both src/ AND tests
# - Must maintain all passing tests
# - Focuses on: DRY, patterns, idioms, architecture
#
# Usage:
#   ./tdd-tcr-refactor-loop "Feature description or requirements"
#   ./tdd-tcr-refactor-loop --bead <bead-id>      # Use bead issue as requirements
#   ./tdd-tcr-refactor-loop -b <bead-id>          # Short form
#   ./tdd-tcr-refactor-loop --all                 # Process ALL open beads (sorted by priority)
#   ./tdd-tcr-refactor-loop -a                    # Short form for --all
#   ./tdd-tcr-refactor-loop --kill                # Kill all running TDD-TCR processes
#   ./tdd-tcr-refactor-loop --reset               # Kill processes + reset git + unlock files
#

set -eo pipefail

#---------------------------------------------------------------------------
# Process Management - Kill/Reset functionality
#---------------------------------------------------------------------------

SCRIPT_NAME="tdd-tcr-refactor-loop"
PIDFILE="/tmp/tdd-tcr-refactor.pid"

# Kill all TDD-TCR related processes
kill_all_processes() {
    echo "Killing all TDD-TCR related processes..."
    local my_pid=$$
    local my_ppid=$PPID

    # Kill child claude processes spawned by this script
    pkill -9 -f "claude.*AUDITOR" 2>/dev/null || true
    pkill -9 -f "claude.*IMPLEMENTER" 2>/dev/null || true
    pkill -9 -f "claude.*ARCHITECT" 2>/dev/null || true
    pkill -9 -f "claude.*REVIEWER" 2>/dev/null || true

    # Kill any other instances of this script (except current PID and parent)
    for pid in $(pgrep -f "$SCRIPT_NAME" 2>/dev/null || true); do
        if [ "$pid" != "$my_pid" ] && [ "$pid" != "$my_ppid" ]; then
            kill -9 "$pid" 2>/dev/null || true
        fi
    done

    # Remove old PID file
    rm -f "$PIDFILE"

    sleep 1
    echo "All TDD-TCR processes killed."
}

# Full reset: kill processes + reset git state + unlock files
full_reset() {
    echo "Performing full reset..."

    # Kill processes first
    kill_all_processes

    # Unlock all files
    echo "Unlocking all files..."
    chmod -R u+w src/ 2>/dev/null || true
    chmod -R u+w test/ 2>/dev/null || true

    # Reset any in-progress beads back to open
    if command -v bd >/dev/null 2>&1; then
        echo "Resetting in-progress beads to open..."
        bd list --status in-progress --json 2>/dev/null | jq -r '.[].id' 2>/dev/null | while read bead_id; do
            [ -n "$bead_id" ] && bd update "$bead_id" --status open 2>/dev/null || true
        done
    fi

    # Clean up temp files
    rm -f "$HISTORY_FILE" 2>/dev/null || true
    rm -f "$PIDFILE" 2>/dev/null || true

    echo "Full reset complete. Ready for fresh start."
}

# Handle --kill and --reset flags (exit after)
case "${1:-}" in
    --kill|-k)
        kill_all_processes
        exit 0
        ;;
    --reset|-r)
        full_reset
        exit 0
        ;;
esac

# ALWAYS reset on startup - clean slate every run
echo "Resetting environment for clean start..."
kill_all_processes
chmod -R u+w src/ 2>/dev/null || true
chmod -R u+w test/ 2>/dev/null || true
rm -f "$HISTORY_FILE" 2>/dev/null || true

# Write PID file for tracking
echo $$ > "$PIDFILE"

#---------------------------------------------------------------------------
# Bead Issue Integration
#---------------------------------------------------------------------------
BEADS_DIR=".beads"
CURRENT_BEAD_ID=""
BEAD_MODE=false
ALL_BEADS_MODE=false
BEAD_JSON=""
BEAD_TITLE=""

# Track results across all beads
declare -a COMPLETED_BEADS=()
declare -a FAILED_BEADS=()
declare -a SKIPPED_BEADS=()

# Find bead by ID in .beads/*.jsonl files
find_bead() {
    local bead_id="$1"
    local bead_json=""

    # Try bd command (if available) for better integration
    # Note: bd show --json returns an array, so extract first element
    if command -v bd >/dev/null 2>&1; then
        bead_json=$(bd show "$bead_id" --json 2>/dev/null | jq '.[0]' 2>/dev/null)
        if [ -n "$bead_json" ] && [ "$bead_json" != "null" ]; then
            echo "$bead_json"
            return 0
        fi
    fi

    # Fallback to manual search
    for jsonl_file in "$BEADS_DIR"/*.jsonl; do
        [ -f "$jsonl_file" ] || continue
        bead_json=$(grep -h "\"id\":\"$bead_id\"" "$jsonl_file" 2>/dev/null | head -1)
        if [ -n "$bead_json" ]; then
            echo "$bead_json"
            return 0
        fi
    done
    return 1
}

# Get all open beads sorted by priority (P0 first, then P1, P2, etc.)
# Uses bv --robot-next for graph-aware priority (respects blockers, PageRank, etc.)
get_all_open_beads() {
    local all_beads=""

    # Try bv --robot-triage first (best: graph-aware, respects blockers)
    if command -v bv >/dev/null 2>&1; then
        # Use --recipe actionable to get only ready-to-work beads
        bv --recipe actionable --robot-plan 2>/dev/null | \
            jq -r '.plan.tracks[].items[].id' 2>/dev/null && return 0
    fi

    # Fallback to bd ready command
    if command -v bd >/dev/null 2>&1; then
        bd ready --json 2>/dev/null | jq -r '.[].id' 2>/dev/null && return 0
    fi

    # Final fallback: manual search
    for jsonl_file in "$BEADS_DIR"/*.jsonl; do
        [ -f "$jsonl_file" ] || continue
        # Get all lines with status "open", extract id and priority for sorting
        while IFS= read -r line; do
            if echo "$line" | jq -e 'select(.status == "open")' >/dev/null 2>&1; then
                local id=$(echo "$line" | jq -r '.id')
                local priority=$(echo "$line" | jq -r '.priority // 99')
                echo "$priority $id"
            fi
        done < "$jsonl_file"
    done | sort -n | cut -d' ' -f2
}

# Count open beads
count_open_beads() {
    get_all_open_beads | wc -l
}

# Extract field from bead JSON
bead_field() {
    local json="$1"
    local field="$2"
    echo "$json" | jq -r ".$field // empty" 2>/dev/null
}

# Update bead status in the jsonl file
update_bead_status() {
    local bead_id="$1"
    local new_status="$2"
    local close_reason="${3:-}"

    # Note: bv is read-only (graph analysis), use bd for updates
    # Try bd command first (if available)
    if command -v bd >/dev/null 2>&1; then
        case "$new_status" in
            closed)
                bd close "$bead_id" ${close_reason:+--reason "$close_reason"} 2>/dev/null && return 0
                ;;
            in_progress|in-progress)
                bd update "$bead_id" --status in-progress 2>/dev/null && return 0
                ;;
            failed)
                # Add comment about failure, keep open for manual review
                if [ -n "$close_reason" ]; then
                    bd comment "$bead_id" "AUTOMATED FAILURE: $close_reason" 2>/dev/null || true
                fi
                bd update "$bead_id" --status open 2>/dev/null && return 0
                ;;
            *)
                bd update "$bead_id" --status "$new_status" 2>/dev/null && return 0
                ;;
        esac
    fi

    # Fallback to manual update
    for jsonl_file in "$BEADS_DIR"/*.jsonl; do
        [ -f "$jsonl_file" ] || continue
        if grep -q "\"id\":\"$bead_id\"" "$jsonl_file" 2>/dev/null; then
            local tmp_file=$(mktemp)
            local now=$(date -Iseconds)

            while IFS= read -r line; do
                if echo "$line" | grep -q "\"id\":\"$bead_id\""; then
                    # Update status
                    line=$(echo "$line" | jq -c ".status = \"$new_status\" | .updated_at = \"$now\"")
                    # Add close fields if closing
                    if [ "$new_status" = "closed" ] && [ -n "$close_reason" ]; then
                        line=$(echo "$line" | jq -c ".closed_at = \"$now\" | .close_reason = \"$close_reason\"")
                    fi
                fi
                echo "$line"
            done < "$jsonl_file" > "$tmp_file"

            mv "$tmp_file" "$jsonl_file"
            return 0
        fi
    done
    return 1
}

# Build requirements string from bead fields
build_requirements_from_bead() {
    local bead_json="$1"
    local title=$(bead_field "$bead_json" "title")
    local description=$(bead_field "$bead_json" "description")
    local acceptance=$(bead_field "$bead_json" "acceptance_criteria")

    cat <<EOF
## $title

$description

### Acceptance Criteria
$acceptance
EOF
}

# Create a new bead from architect findings with proper dependencies and scope
create_bead_from_architect() {
    local title="$1"
    local description="$2"
    local priority="${3:-2}"  # Default to P2 (medium)
    local current_bead_id="${4:-}"  # Link to current bead if available

    # Enhance description with context and make it actionable
    local enhanced_desc="$description

## Context
- Identified during refactoring in TDD-TCR loop
- Current codebase state allows tests to pass but has technical debt
- Should be addressed to maintain code quality

## Scope
This is a FOCUSED refactoring task. Should be completable in one TDD-TCR session.
- Modify only the specific area mentioned
- Ensure all existing tests continue to pass
- Add tests if behavior changes"

    if [ -n "$current_bead_id" ]; then
        enhanced_desc="$enhanced_desc

## Related Work
- Discovered while working on: $current_bead_id"
    fi

    # Try bd command first
    if command -v bd >/dev/null 2>&1; then
        local create_args=(
            --title "$title"
            --description "$enhanced_desc"
            --priority "$priority"
            --tags "architect-generated,code-smell,technical-debt,refactoring"
        )

        # Link to current bead if available
        if [ -n "$current_bead_id" ]; then
            create_args+=(--related-to "$current_bead_id")
        fi

        local new_bead_id=$(bd create "${create_args[@]}" --json 2>/dev/null | jq -r '.id' 2>/dev/null)

        if [ -n "$new_bead_id" ] && [ "$new_bead_id" != "null" ]; then
            log_success "Created bead $new_bead_id: $title"
            BEADS_CREATED_BY_ARCHITECT=$((BEADS_CREATED_BY_ARCHITECT + 1))
            return 0
        fi
    fi

    # Fallback: create manually in .beads/technical-debt.jsonl
    mkdir -p "$BEADS_DIR"
    local bead_file="$BEADS_DIR/technical-debt.jsonl"
    local new_id="arch-$(date +%s)-$(( RANDOM % 1000 ))"
    local now=$(date -Iseconds)

    local bead_json=$(jq -n \
        --arg id "$new_id" \
        --arg title "$title" \
        --arg desc "$enhanced_desc" \
        --arg pri "$priority" \
        --arg now "$now" \
        --arg parent "$current_bead_id" \
        '{
            id: $id,
            title: $title,
            description: $desc,
            priority: ($pri | tonumber),
            status: "open",
            tags: ["architect-generated", "code-smell", "technical-debt", "refactoring"],
            created_at: $now,
            updated_at: $now,
            created_by: "tdd-tcr-refactor-loop",
            parent_bead: (if $parent != "" then $parent else null end)
        }')

    echo "$bead_json" >> "$bead_file"
    log_success "Created bead $new_id: $title (in $bead_file)"
    BEADS_CREATED_BY_ARCHITECT=$((BEADS_CREATED_BY_ARCHITECT + 1))
    return 0
}

# Parse architect output and create beads from CREATE_BEAD directives
parse_and_create_beads() {
    local architect_output="$1"
    local in_bead=false
    local bead_title=""
    local bead_description=""
    local bead_priority="2"

    while IFS= read -r line; do
        if [[ "$line" =~ ^CREATE_BEAD:\ (.+)$ ]]; then
            in_bead=true
            bead_title="${BASH_REMATCH[1]}"
            bead_description=""
            bead_priority="2"
        elif [[ "$line" =~ ^DESCRIPTION:\ (.+)$ ]] && [ "$in_bead" = true ]; then
            bead_description="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^PRIORITY:\ ([0-3])$ ]] && [ "$in_bead" = true ]; then
            bead_priority="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^---$ ]] && [ "$in_bead" = true ]; then
            # End of bead definition - create it
            if [ -n "$bead_title" ] && [ -n "$bead_description" ]; then
                create_bead_from_architect "$bead_title" "$bead_description" "$bead_priority" "$CURRENT_BEAD_ID"
            fi
            in_bead=false
            bead_title=""
            bead_description=""
            bead_priority="2"
        elif [ "$in_bead" = true ] && [[ "$line" =~ ^DESCRIPTION: ]]; then
            # Continue multi-line description
            bead_description="$bead_description $line"
        fi
    done <<< "$architect_output"
}

# Parse --bead/-b argument
parse_bead_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --bead|-b)
                BEAD_MODE=true
                CURRENT_BEAD_ID="$2"
                shift 2
                ;;
            *)
                # Not a bead arg, return remaining args
                echo "$@"
                return
                ;;
        esac
    done
}

# Show bv triage summary (if available)
show_bv_triage() {
    if command -v bv >/dev/null 2>&1; then
        log_info "Getting graph-aware triage from bv..."
        local triage_json=$(bv --robot-triage 2>/dev/null)
        if [ -n "$triage_json" ]; then
            echo ""
            echo -e "${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
            echo -e "${CYAN}  BV GRAPH TRIAGE${NC}"
            echo -e "${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
            echo "$triage_json" | jq -r '.triage.quick_ref |
                "  Open: \(.open_count)\n  Actionable: \(.actionable_count)\n  Blocked: \(.blocked_count)\n  In Progress: \(.in_progress_count)"' 2>/dev/null || echo "  (triage data unavailable)"
            echo ""
            echo -e "${BOLD}Top Recommendation:${NC}"
            echo "$triage_json" | jq -r '.triage.quick_ref.top_picks[0] |
                "  ID: \(.id)\n  Title: \(.title)\n  Score: \(.score)\n  Unblocks: \(.unblocks) issues"' 2>/dev/null || echo "  (no recommendations)"
            echo -e "${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
            echo ""
        fi
    fi
}

# Dependency checks
check_dependencies() {
    local missing=()
    command -v claude >/dev/null 2>&1 || missing+=("claude")
    command -v uuidgen >/dev/null 2>&1 || missing+=("uuidgen")
    command -v jq >/dev/null 2>&1 || missing+=("jq")
    git rev-parse --git-dir >/dev/null 2>&1 || missing+=("git (not in a repository)")

    if [ ${#missing[@]} -gt 0 ]; then
        echo "Error: Missing dependencies: ${missing[*]}"
        exit 1
    fi

    # Optional tools (warn but don't fail)
    local optional_missing=()
    command -v bv >/dev/null 2>&1 || optional_missing+=("bv (graph-aware triage)")
    command -v bd >/dev/null 2>&1 || optional_missing+=("bd (bead management)")
    command -v codanna >/dev/null 2>&1 || optional_missing+=("codanna (semantic search)")

    if [ ${#optional_missing[@]} -gt 0 ]; then
        echo -e "${YELLOW}Optional tools not found: ${optional_missing[*]}${NC}"
        echo -e "${DIM}Install from: https://github.com/Dicklesworthstone/beads_viewer${NC}"
        echo -e "${DIM}            https://github.com/bartolli/codanna${NC}"
        echo ""
    fi
}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
WHITE='\033[1;37m'
BOLD='\033[1m'
DIM='\033[2m'
ITALIC='\033[3m'
UNDERLINE='\033[4m'
BLINK='\033[5m'
NC='\033[0m' # No Color

# Background colors
BG_RED='\033[41m'
BG_GREEN='\033[42m'
BG_YELLOW='\033[43m'
BG_BLUE='\033[44m'
BG_MAGENTA='\033[45m'
BG_CYAN='\033[46m'
BG_WHITE='\033[47m'

# Box drawing characters
BOX_TL='‚ïî'
BOX_TR='‚ïó'
BOX_BL='‚ïö'
BOX_BR='‚ïù'
BOX_H='‚ïê'
BOX_V='‚ïë'
BOX_LT='‚ï†'
BOX_RT='‚ï£'

# Progress indicators
SPINNER_CHARS='‚†ã‚†ô‚†π‚†∏‚†º‚†¥‚†¶‚†ß‚†á‚†è'
PROGRESS_FULL='‚ñà'
PROGRESS_EMPTY='‚ñë'

# Configuration
SRC_DIR="src"
TEST_DIR="test"
MAX_IMPL_ATTEMPTS=3
MAX_ITERATIONS=5
REFACTOR_INTERVAL=3  # Run architect every N successful implementations
PAUSE_BETWEEN_BEADS=5  # seconds between beads in --all mode
ESCALATION_THRESHOLD=3  # Escalate to Sonnet after N consecutive failures
AI_LEARNING_DIR=".factory/learnings"
AI_LEARNING_FILE=".factory/learnings/session-learnings.md"

# Handle requirements from bead, file, or argument
REQUIREMENTS=""
REQUIREMENTS_SOURCE=""

# Setup a single bead for processing
setup_bead() {
    local bead_id="$1"
    CURRENT_BEAD_ID="$bead_id"
    BEAD_MODE=true

    BEAD_JSON=$(find_bead "$CURRENT_BEAD_ID")
    if [ -z "$BEAD_JSON" ]; then
        echo "Error: Bead '$CURRENT_BEAD_ID' not found in $BEADS_DIR/"
        return 1
    fi

    BEAD_STATUS=$(bead_field "$BEAD_JSON" "status")
    if [ "$BEAD_STATUS" != "open" ]; then
        echo "Skipping bead '$CURRENT_BEAD_ID' - status is '$BEAD_STATUS' (not 'open')"
        return 2
    fi

    REQUIREMENTS=$(build_requirements_from_bead "$BEAD_JSON")
    REQUIREMENTS_SOURCE="bead: $CURRENT_BEAD_ID"
    BEAD_TITLE=$(bead_field "$BEAD_JSON" "title")

    # Reset statistics for this bead
    TCR_COMMITS=0
    TCR_REVERTS=0
    REFACTOR_COUNT=0
    SUCCESSFUL_IMPLS=0

    return 0
}

# Check for --all mode first
if [ "$1" = "--all" ] || [ "$1" = "-a" ]; then
    ALL_BEADS_MODE=true
    BEAD_MODE=true
# Check for single bead mode
elif [ "$1" = "--bead" ] || [ "$1" = "-b" ]; then
    BEAD_MODE=true
    CURRENT_BEAD_ID="$2"

    if [ -z "$CURRENT_BEAD_ID" ]; then
        echo "Error: --bead requires a bead ID"
        exit 1
    fi

    BEAD_JSON=$(find_bead "$CURRENT_BEAD_ID")
    if [ -z "$BEAD_JSON" ]; then
        echo "Error: Bead '$CURRENT_BEAD_ID' not found in $BEADS_DIR/"
        exit 1
    fi

    BEAD_STATUS=$(bead_field "$BEAD_JSON" "status")
    if [ "$BEAD_STATUS" != "open" ]; then
        echo "Warning: Bead '$CURRENT_BEAD_ID' has status '$BEAD_STATUS' (not 'open')"
        read -p "Continue anyway? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
    fi

    REQUIREMENTS=$(build_requirements_from_bead "$BEAD_JSON")
    REQUIREMENTS_SOURCE="bead: $CURRENT_BEAD_ID"
    BEAD_TITLE=$(bead_field "$BEAD_JSON" "title")
elif [ -f "$1" ]; then
    REQUIREMENTS=$(cat "$1")
    REQUIREMENTS_SOURCE="file: $1"
else
    REQUIREMENTS="$1"
    REQUIREMENTS_SOURCE="argument"
fi

# Detect language from project files
detect_language() {
    if [ -f "gleam.toml" ]; then
        echo "gleam"
    elif [ -f "go.mod" ]; then
        echo "go"
    elif [ -f "Cargo.toml" ]; then
        echo "rust"
    elif [ -f "pyproject.toml" ] || [ -f "setup.py" ]; then
        echo "python"
    else
        echo "unknown"
    fi
}

PROJECT_LANG=$(detect_language)
TEST_CMD="gleam test"
case "$PROJECT_LANG" in
    gleam) TEST_CMD="gleam test" ;;
    go) TEST_CMD="go test ./..." ;;
    rust) TEST_CMD="cargo test" ;;
    python) TEST_CMD="pytest" ;;
esac

# Statistics
TCR_COMMITS=0
TCR_REVERTS=0
REFACTOR_COUNT=0
SUCCESSFUL_IMPLS=0
CONSECUTIVE_FAILURES=0
BEADS_CREATED_BY_ARCHITECT=0

# Context passing between agents
HISTORY_FILE=".tdd-history.md"
LAST_AUDITOR_REASONING=""
LAST_IMPL_REASONING=""

# Initialize AI learning system
init_ai_learning() {
    mkdir -p "$AI_LEARNING_DIR"

    if [ ! -f "$AI_LEARNING_FILE" ]; then
        cat > "$AI_LEARNING_FILE" << 'LEARNINGEOF'
# AI Session Learnings

This file accumulates knowledge across TDD-TCR-REFACTOR sessions to help AI agents
learn from past successes and failures.

## Purpose
- Document what works well in this codebase
- Capture patterns that should be reused
- Record pitfalls to avoid
- Share language-specific idioms discovered

## Format
Each session appends its learnings below, tagged with timestamp and bead context.

---

LEARNINGEOF
    fi
}

# Load AI learnings to provide context to agents
load_ai_learnings() {
    if [ -f "$AI_LEARNING_FILE" ]; then
        tail -n 200 "$AI_LEARNING_FILE" 2>/dev/null || echo "(no learnings yet)"
    else
        echo "(no learnings yet)"
    fi
}

# Save AI learnings from session
save_ai_learning() {
    local content="$1"
    local timestamp=$(date -Iseconds)
    local bead_info=""

    if [ "$BEAD_MODE" = true ]; then
        bead_info="Bead: $CURRENT_BEAD_ID ($BEAD_TITLE)"
    fi

    {
        echo ""
        echo "---"
        echo ""
        echo "## Session: $timestamp"
        [ -n "$bead_info" ] && echo "$bead_info"
        echo "Stats: $TCR_COMMITS commits, $TCR_REVERTS reverts, $REFACTOR_COUNT refactors, $BEADS_CREATED_BY_ARCHITECT new beads"
        echo ""
        echo "$content"
    } >> "$AI_LEARNING_FILE"
}

# Initialize history file
init_history() {
    cat > "$HISTORY_FILE" << 'HISTEOF'
# TDD-TCR-REFACTOR Session History

This file tracks the reasoning from each agent to provide context to subsequent agents.

---

HISTEOF
}

# Append to history
append_history() {
    local role="$1"
    local iteration="$2"
    local content="$3"

    echo "" >> "$HISTORY_FILE"
    echo "## Iteration $iteration - $role" >> "$HISTORY_FILE"
    echo "" >> "$HISTORY_FILE"
    echo "$content" >> "$HISTORY_FILE"
    echo "" >> "$HISTORY_FILE"
    echo "---" >> "$HISTORY_FILE"
}

# Get recent history (last N entries, trimmed for context window)
get_recent_history() {
    local max_lines="${1:-100}"
    tail -n "$max_lines" "$HISTORY_FILE" 2>/dev/null || echo "(no history yet)"
}

#---------------------------------------------------------------------------
# Utility functions
#---------------------------------------------------------------------------

# Get terminal width
get_term_width() {
    tput cols 2>/dev/null || echo 80
}

# Draw a horizontal line (handles multi-byte UTF-8 characters)
draw_line() {
    local char="${1:-‚ïê}"
    local width="${2:-$(get_term_width)}"
    local result=""
    for ((i=0; i<width; i++)); do
        result+="$char"
    done
    printf '%s' "$result"
}

# Center text (pads both left and right to fill width)
center_text() {
    local text="$1"
    local width="${2:-$(get_term_width)}"
    local text_len=${#text}
    local left_pad=$(( (width - text_len) / 2 ))
    local right_pad=$(( width - text_len - left_pad ))
    printf '%*s%s%*s' "$left_pad" '' "$text" "$right_pad" ''
}

# Draw fancy box
draw_box() {
    local title="$1"
    local color="$2"
    local width=$(get_term_width)
    local inner_width=$((width - 4))

    echo ""
    echo -e "${color}‚ïî$(draw_line '‚ïê' $((width-2)))‚ïó${NC}"
    echo -e "${color}‚ïë$(center_text "$title" $((width-2)))‚ïë${NC}"
    echo -e "${color}‚ïö$(draw_line '‚ïê' $((width-2)))‚ïù${NC}"
    echo ""
}

# Draw status dashboard
draw_dashboard() {
    local iteration="$1"
    local width=$(get_term_width)

    echo -e "${DIM}$(draw_line '‚îÄ' $width)${NC}"
    echo -e "${BOLD}  üìä DASHBOARD${NC}  ‚îÇ  Iter: ${CYAN}$iteration${NC}  ‚îÇ  ‚úì ${GREEN}$TCR_COMMITS${NC}  ‚îÇ  ‚úó ${RED}$TCR_REVERTS${NC}  ‚îÇ  üèõÔ∏è ${WHITE}$REFACTOR_COUNT${NC}  ‚îÇ  üîß ${YELLOW}$BEADS_CREATED_BY_ARCHITECT${NC}  ‚îÇ  ‚ö†Ô∏è ${MAGENTA}$CONSECUTIVE_FAILURES${NC}"
    echo -e "${DIM}$(draw_line '‚îÄ' $width)${NC}"
}

# Progress bar
draw_progress() {
    local current="$1"
    local total="$2"
    local width=30
    local filled=$((current * width / total))
    local empty=$((width - filled))
    local percent=$((current * 100 / total))

    printf "${CYAN}["
    printf '%*s' "$filled" '' | tr ' ' "$PROGRESS_FULL"
    printf '%*s' "$empty" '' | tr ' ' "$PROGRESS_EMPTY"
    printf "] ${WHITE}%3d%%${NC}" "$percent"
}

log_phase() {
    local title="$1"
    draw_box "$title" "${BLUE}"
}

log_auditor() {
    echo ""
    echo -e "${YELLOW}‚îå$(draw_line '‚îÄ' 58)‚îê${NC}"
    echo -e "${YELLOW}‚îÇ  üîç AUDITOR: ${BOLD}$1${NC}${YELLOW}$(printf '%*s' $((44 - ${#1})) '')‚îÇ${NC}"
    echo -e "${YELLOW}‚îî$(draw_line '‚îÄ' 58)‚îò${NC}"
    echo ""
}

log_implementer() {
    echo ""
    echo -e "${GREEN}‚îå$(draw_line '‚îÄ' 58)‚îê${NC}"
    echo -e "${GREEN}‚îÇ  üîß IMPLEMENTER: ${BOLD}$1${NC}${GREEN}$(printf '%*s' $((40 - ${#1})) '')‚îÇ${NC}"
    echo -e "${GREEN}‚îî$(draw_line '‚îÄ' 58)‚îò${NC}"
    echo ""
}

log_architect() {
    echo ""
    echo -e "${WHITE}${BOLD}‚ïî$(draw_line '‚ïê' 58)‚ïó${NC}"
    echo -e "${WHITE}${BOLD}‚ïë  üèõÔ∏è  ARCHITECT: $1$(printf '%*s' $((40 - ${#1})) '')‚ïë${NC}"
    echo -e "${WHITE}${BOLD}‚ïö$(draw_line '‚ïê' 58)‚ïù${NC}"
    echo ""
}

log_reviewer() {
    echo ""
    echo -e "${MAGENTA}‚ïî$(draw_line '‚ïê' 58)‚ïó${NC}"
    echo -e "${MAGENTA}‚ïë  üìã REVIEWER: ${BOLD}$1${NC}${MAGENTA}$(printf '%*s' $((42 - ${#1})) '')‚ïë${NC}"
    echo -e "${MAGENTA}‚ïö$(draw_line '‚ïê' 58)‚ïù${NC}"
    echo ""
}

log_info() {
    echo -e "  ${CYAN}‚Üí${NC} $1"
}

log_success() {
    echo -e "  ${GREEN}‚úì${NC} ${GREEN}$1${NC}"
}

log_warning() {
    echo -e "  ${YELLOW}‚ö†${NC} ${YELLOW}$1${NC}"
}

log_error() {
    echo -e "  ${RED}‚úó${NC} ${RED}$1${NC}"
}

log_tcr() {
    echo -e "  ${MAGENTA}‚ü≥${NC} ${BOLD}TCR:${NC} $1"
}

log_tdd_phase() {
    local phase="$1"
    local color="$2"
    local emoji="$3"
    echo -e "\n  ${color}${emoji} ${BOLD}${phase}${NC}"
}

# Show TDD cycle indicator
show_tdd_cycle() {
    local phase="$1"  # red, green, refactor
    local r_color="${DIM}"
    local g_color="${DIM}"
    local f_color="${DIM}"

    case "$phase" in
        red) r_color="${RED}${BOLD}" ;;
        green) g_color="${GREEN}${BOLD}" ;;
        refactor) f_color="${WHITE}${BOLD}" ;;
    esac

    echo -e "\n  TDD Cycle: [${r_color}RED${NC}] ‚Üí [${g_color}GREEN${NC}] ‚Üí [${f_color}REFACTOR${NC}]"
}

#---------------------------------------------------------------------------
# Lock management
#---------------------------------------------------------------------------

lock_all() {
    log_info "Locking all source and test files..."
    chmod -R a-w "$SRC_DIR/" 2>/dev/null || true
    chmod -R a-w "$TEST_DIR/" 2>/dev/null || true
}

unlock_src() {
    log_info "Unlocking src/ for implementer..."
    chmod -R u+w "$SRC_DIR/"
}

lock_src() {
    log_info "Locking src/..."
    chmod -R a-w "$SRC_DIR/"
}

unlock_tests() {
    log_info "Unlocking test/ for auditor..."
    chmod -R u+w "$TEST_DIR/"
}

lock_tests() {
    log_info "Locking test/..."
    chmod -R a-w "$TEST_DIR/"
}

unlock_all() {
    log_info "Unlocking all files..."
    chmod -R u+w "$SRC_DIR/" 2>/dev/null || true
    chmod -R u+w "$TEST_DIR/" 2>/dev/null || true
}

#---------------------------------------------------------------------------
# MUNGER PATCH 1: THE CHECKLIST (State Management)
#---------------------------------------------------------------------------

TODO_FILE=".tdd-todo.md"

init_todo() {
    if [ ! -f "$TODO_FILE" ]; then
        cat > "$TODO_FILE" << 'TODOEOF'
# Implementation Checklist

TODOEOF
        # Extract requirements into checklist items
        if [ -n "$REQUIREMENTS" ]; then
            echo "$REQUIREMENTS" | grep -E "^[-*]|^[0-9]+\." | sed 's/^/- [ ] /' >> "$TODO_FILE" || {
                echo "- [ ] Implement requirements" >> "$TODO_FILE"
            }
        else
            echo "- [ ] Implement core logic" >> "$TODO_FILE"
        fi
    fi
}

update_todo() {
    local completed_item="$1"
    if [ -f "$TODO_FILE" ]; then
        # Escape special chars for sed
        local escaped_item=$(printf '%s\n' "$completed_item" | sed 's/[\/&]/\\&/g')
        sed -i "s/- \[ \] $escaped_item/- [x] $escaped_item/g" "$TODO_FILE" 2>/dev/null || true
    fi
}

get_todo_context() {
    if [ -f "$TODO_FILE" ]; then
        cat "$TODO_FILE"
    else
        echo "(checklist not yet initialized)"
    fi
}

#---------------------------------------------------------------------------
# MUNGER PATCH 2 & 3: HOSTILE NEGOTIATION + CIRCUIT BREAKER
#---------------------------------------------------------------------------

negotiate_contract() {
    local iteration="$1"
    local last_result="$2"

    # PARETO OPTIMIZATION: Only negotiate if we just failed (MUNGER PATCH 4)
    if [ "$CONSECUTIVE_FAILURES" -eq 0 ] && [ $((iteration % 5)) -ne 0 ]; then
        log_info "Smooth sailing - skipping negotiation (no failures detected)"
        return 0
    fi

    if [ "$CONSECUTIVE_FAILURES" -gt 0 ]; then
        log_phase "COUNCIL OF WAR (triggered by $CONSECUTIVE_FAILURES failure(s))"
    else
        log_phase "COUNCIL OF WAR (scheduled 5-cycle check)"
    fi

    local attempts=0
    local max_attempts=3
    local agreed_plan=""

    while [ $attempts -lt $max_attempts ]; do
        log_info "Negotiation attempt $((attempts + 1)) of $max_attempts"

        # 1. Auditor Proposal (With Checklist Context)
        local todo_content=$(get_todo_context)

        log_info "Auditor proposing next test..."
        local proposal=$(claude -p \
            --model sonnet \
            --append-system-prompt "PROPOSE: Pick next unchecked item from checklist. Create focused test plan." \
            "CHECKLIST:
$todo_content

LAST_RESULT: $last_result

Pick ONE unchecked item. Propose a test that forces good design. Be specific." 2>&1 </dev/null)

        if [ $? -ne 0 ]; then
            log_warning "Auditor failed to respond, retrying..."
            attempts=$((attempts + 1))
            continue
        fi

        # 2. Implementer Veto (HOSTILE PERSONA)
        log_info "Hostile implementer reviewing proposal..."
        local verdict=$(claude -p \
            --model sonnet \
            --append-system-prompt "You are a HOSTILE Senior Engineer. VETO bad ideas. If it's vague, too big, or untestable, SAY 'VETO:reason'. If solid, SAY 'AGREED'." \
            "PROPOSAL:
$proposal

CRITIQUE: Is this proposal vague? Too big (>30 lines)? Untestable? If ANY flaw, VETO it. Otherwise AGREE." 2>&1 </dev/null)

        if [ $? -ne 0 ]; then
            log_warning "Implementer failed to respond, retrying..."
            attempts=$((attempts + 1))
            continue
        fi

        if echo "$verdict" | grep -qi "AGREED"; then
            log_success "Negotiation successful - plan agreed"
            echo "$proposal"
            return 0
        fi

        log_warning "VETO: $(echo "$verdict" | head -n 1)"
        attempts=$((attempts + 1))
    done

    # CIRCUIT BREAKER (MUNGER PATCH 3)
    log_error "Negotiation deadlocked after $max_attempts attempts - forcing emergency plan"
    log_warning "Forcing escalation to simpler test strategy"

    cat > /tmp/emergency_plan.txt << 'EMERGENCYEOF'
Emergency fallback: Write a trivial test for a helper function.
Do not attempt complex logic. Test should:
1. Have clear input
2. Have predictable output
3. Take <5 lines to pass

Example: test that a simple pure function returns expected value.
EMERGENCYEOF

    cat /tmp/emergency_plan.txt
    rm /tmp/emergency_plan.txt
    return 1
}

#---------------------------------------------------------------------------
# Git/TCR operations
#---------------------------------------------------------------------------

tcr_commit() {
    local iteration="$1"
    local message="$2"

    # SAFETY CHECK: Reject files that shadow Gleam stdlib
    local bad_files
    bad_files=$(git status --porcelain | grep -E "^\?\?|^ M|^A " | awk '{print $2}' | grep -E "^src/gleam/" || true)
    if [ -n "$bad_files" ]; then
        log_error "BLOCKED: Files shadowing Gleam stdlib detected!"
        echo "$bad_files" | while read f; do log_error "  - $f"; done
        log_error "Removing bad files and reverting..."
        echo "$bad_files" | xargs -r rm -f 2>/dev/null || true
        rmdir src/gleam/otp src/gleam 2>/dev/null || true
        return 1
    fi

    log_tcr "Tests PASSED - Committing changes..."
    git add -A
    git commit -m "PASS(tcr-$iteration): $message" --no-verify 2>/dev/null || true
    TCR_COMMITS=$((TCR_COMMITS + 1))
    log_success "TCR Commit #$TCR_COMMITS"
}

tcr_revert() {
    local iteration="$1"

    log_tcr "Tests FAILED - Reverting implementation changes..."
    git checkout HEAD -- "$SRC_DIR/" 2>/dev/null || true
    git clean -fd "$SRC_DIR/" 2>/dev/null || true
    TCR_REVERTS=$((TCR_REVERTS + 1))
    log_error "TCR Revert #$TCR_REVERTS - Implementation discarded"
}

#---------------------------------------------------------------------------
# Test execution
#---------------------------------------------------------------------------

# Run tests and capture output. Sets LAST_TEST_OUTPUT and returns exit code.
run_tests() {
    log_info "Running tests ($TEST_CMD)..."
    LAST_TEST_OUTPUT=$($TEST_CMD 2>&1) && return 0 || return 1
}

# Run tests silently, just for pass/fail check
run_tests_quiet() {
    $TEST_CMD >/dev/null 2>&1
}

#---------------------------------------------------------------------------
# HARD GATES - Non-AI quality enforcement (compiler, tests)
#---------------------------------------------------------------------------

# Hard gate: Compilation must succeed with NO ERRORS and NO WARNINGS.
# This is NOT AI judgment - this is the compiler's verdict.
hard_gate_compile() {
    log_info "HARD GATE: Checking compilation (gleam build)..."
    local output
    output=$(gleam build 2>&1)
    local exit_code=$?

    # Check for compilation failure
    if [ $exit_code -ne 0 ]; then
        log_error "HARD GATE FAIL: Compilation error - REVERTING"
        echo "$output" | head -20
        LAST_COMPILE_ERROR="$output"
        return 1
    fi

    # Check for warnings (Gleam outputs warnings to stderr/stdout)
    if echo "$output" | grep -qiE "warning:|warn:"; then
        log_error "HARD GATE FAIL: Compilation warnings detected - REVERTING"
        echo "$output" | grep -iE "warning:|warn:" | head -10
        LAST_COMPILE_ERROR="WARNINGS: $output"
        return 1
    fi

    log_success "HARD GATE PASS: Code compiles with no errors or warnings"
    return 0
}

# Hard gate: Tests must pass. Returns 0 on success, 1 on failure.
# This is NOT AI judgment - this is the test suite's verdict.
hard_gate_tests() {
    log_info "HARD GATE: Running tests ($TEST_CMD)..."
    if LAST_TEST_OUTPUT=$($TEST_CMD 2>&1); then
        log_success "HARD GATE PASS: All tests pass"
        return 0
    else
        log_error "HARD GATE FAIL: Tests failed - REVERTING"
        echo "$LAST_TEST_OUTPUT" | tail -30
        return 1
    fi
}

# Combined hard gate: compile + tests. Both must pass or revert.
hard_gate_all() {
    if ! hard_gate_compile; then
        return 1
    fi
    if ! hard_gate_tests; then
        return 1
    fi
    return 0
}

#---------------------------------------------------------------------------
# CUE Schema Validation
#---------------------------------------------------------------------------

CUE_CONTRACT=".factory/cue/contract.cue"

# Validate AI output against CUE contract
# Usage: validate_ai_output "A" "$json_output"
# Schemas: #A=auditor #I=implementer #R=architect #V=reviewer
validate_ai_output() {
    local schema="$1"
    local output="$2"

    # Extract JSON blob from output
    local json
    json=$(echo "$output" | grep -oE '\{[^}]+\}' | grep '"s":' | tail -1)
    [ -z "$json" ] && { log_warning "No JSON in output"; return 1; }

    # Validate with CUE contract
    if echo "$json" | cue vet "$CUE_CONTRACT" -d "#$schema" - 2>/dev/null; then
        echo "$json"
        return 0
    else
        log_warning "Contract validation failed"
        return 1
    fi
}

# Extract field from JSON
jf() { echo "$1" | jq -r "$2" 2>/dev/null; }

#---------------------------------------------------------------------------
# AI Prompts (YAML format for token efficiency)
#---------------------------------------------------------------------------

auditor_prompt() {
    local iteration="$1"
    local last_impl_result="$2"
    local todo_context="$3"

    # CHALLENGER prompt - forces design-driving tests, not lazy field checks
    cat <<EOF
CHALLENGER:$PROJECT_LANG i:$iteration c:$TEST_CMD
REQ:$REQUIREMENTS
$([ -n "$todo_context" ] && echo "CHECKLIST:$todo_context")
$([ -n "$last_impl_result" ] && echo "PREV:$last_impl_result")

YOUR JOB: Write a test that FORCES better design. You FAIL if implementer passes with trivial code.

LAZY(reject): "field exists" "returns Ok" "type compiles" - these waste everyone's time
GOOD(accept): "composable with X" "pure fn Y" "handles edge Z" - forces thought

CUPID-DRIVE: Your test should make implementer confront:
- C: "Can I compose this?" - test interaction between parts
- U: "Does it do ONE thing?" - test should need only that thing
- P: "Is it pure?" - test with same input, expect same output
- I: "Is it idiomatic?" - test |> chains, pattern matching
- D: "Does it speak domain?" - test uses problem language

30-LINE-RULE: If passing needs >30 lines, your test is too big. Split it.
DISCOMFORT-GOAL: Implementer should think "damn, I need to rethink X"

LOCK:src/(readonly) UNLOCK:test/
FILE:test/factory_test.gleam NAME:*_test
OUT:#A{"s":"tw","t":{"n":"x_test","f":"test/factory_test.gleam","b":"CUPID-principle-forced"},"c":0.8,"why":"design-pressure-reason"}|{"s":"rc","c":1.0}
EOF
}

implementer_prompt() {
    local test_output="$1"
    local attempt="$2"
    local auditor_reasoning="$3"
    local ai_learnings="$4"
    local is_escalated="${5:-false}"

    # DEFENDER prompt - extreme minimalism, forced justification
    cat <<EOF
DEFENDER:$PROJECT_LANG c:$TEST_CMD a:$attempt/$MAX_IMPL_ATTEMPTS$([ "$is_escalated" = "true" ] && echo " ESC:$CONSECUTIVE_FAILURES")

TCR-DEATH: FAIL=REVERT. Your code DIES if ANY of these fail. No mercy. No second chances.
HARD-GATES (non-AI, automatic):
1. gleam build - NO errors, NO warnings
2. gleam test - ALL tests pass

FAILING:$test_output

30-LINE-MAX: You have 30 lines. If you need more, REJECT the test:
{"s":"bl","b":"test too big - split into: [smaller test 1] [smaller test 2]","cf":0}

HICKEY: "Simple isn't easy" - complexity is the enemy. Prefer:
- Small composable pure fns over big stateful classes
- Data transformations over mutations
- Explicit over implicit

EVERY LINE MUST JUSTIFY ITSELF:
- "Why can't I delete this line?" - if no answer, delete it
- "Is there a shorter way?" - if yes, use it
- "Am I repeating anything?" - if yes, extract or delete

CUPID-CHECK before writing:
- C: Am I adding dependencies? (bad) Am I making this composable? (good)
- U: Does this fn do ONE thing? If "and" in description, split.
- P: Same input = same output? No hidden state? No side effects in logic?
- I: Using |> pipes? Pattern matching? Result/Option?
- D: Do my names speak the problem domain?

DRY-EXTREME: If you write similar code twice, you've failed. Extract it NOW.

REUSE>CREATE: Can existing code do this? Use it. Don't reinvent.

BAN:src/gleam/* fn>30lines unused magic-numbers stringly-typed imperative-loops
LOCK:test/(readonly) UNLOCK:src/
OUT:#I{"s":"ok","c":[{"f":"src/x.gleam","a":"+","l":N}],"cf":0.9,"justify":"why-each-line-exists"}|{"s":"bl","b":"reason","cf":0}
EOF
}

architect_prompt() {
    local iteration="$1"
    local session_history="$2"
    local ai_learnings="$3"

    # ARBITER prompt - ruthless deletion, metric-driven
    cat <<EOF
ARBITER:$PROJECT_LANG i:$iteration c:$TEST_CMD cm:$TCR_COMMITS rv:$TCR_REVERTS
REQ:$REQUIREMENTS

YOUR MANDATE: DELETE CODE. Less code = fewer bugs = happier humans.

METRICS-FIRST (measure before/after):
- LOC: must decrease or stay flat. Increase = you failed.
- fn count: fewer functions = simpler system
- max fn length: >30 lines = extract or delete
- duplication: ANY repeated pattern = immediate extraction

DELETION HIERARCHY (try each in order):
1. DELETE - Can I remove this entirely? Tests still pass?
2. INLINE - Can I inline this and delete the wrapper?
3. COMBINE - Can two things become one?
4. SIMPLIFY - Can I do this in fewer lines?
5. PURIFY - Can I remove side effects?

CUPID AUDIT (score each file 0-5):
- C(omposable): Small API? Few deps? Pipes well?
- U(nix): One thing? No "and"?
- P(ure): No hidden state? Same in=same out?
- I(diomatic): |> pipes? Pattern match? Result/Option?
- D(omain): Names from problem space?
Score <3 = MUST refactor. Score <2 = CREATE_BEAD for tech debt.

DRY-POLICE: Search for:
- Similar 3-line blocks -> extract helper
- Repeated pattern match arms -> extract fn
- Copy-paste with small changes -> parameterize

SMELL->BEAD: If you find code smell you can't fix now:
CREATE_BEAD:<title> DESC:<issue> PRI:0-3 ---

YOU SUCCEED WHEN: la < lb (lines after < lines before)
OUT:#R{"s":"rf","lb":N,"la":N,"c":[{"t":"d|s|x|r|i","w":"what-deleted"}],"cf":0.9,"cupid":[C,U,P,I,D],"sm":[]}|{"s":"nc","cf":1.0,"cupid":[5,5,5,5,5]}
EOF
}

reviewer_prompt() {
    local acceptance=""
    if [ "$BEAD_MODE" = true ]; then
        acceptance=$(bead_field "$BEAD_JSON" "acceptance_criteria")
    fi

    # JUDGE prompt - ruthless quality gate, CUPID-enforcement
    cat <<EOF
JUDGE:$PROJECT_LANG c:$TEST_CMD cm:$TCR_COMMITS rv:$TCR_REVERTS
REQ:$REQUIREMENTS
$([ -n "$acceptance" ] && echo "AC[$CURRENT_BEAD_ID]:$acceptance")

YOUR JOB: Be the HARD gate. If this code ships with flaws, YOU failed. No mercy.

CUPID-SCORECARD (grade each 0-5, FAIL if any <3):
- C(omposable): Few deps? Small API? Plays well with others? |> friendly?
- U(nix): Does ONE thing? No "and" in description? Single responsibility?
- P(ure): Same input=same output? No hidden state? Side effects isolated?
- I(diomatic): |> pipes? Pattern matching? Result/Option? Gleam conventions?
- D(omain): Types speak problem language? Names from business domain?

QUALITY-GATES (any FAIL = reject):
- [ ] All acceptance criteria met with evidence (file:line)
- [ ] Tests actually test behavior, not just "exists"
- [ ] No function >30 lines
- [ ] No repeated code patterns (DRY)
- [ ] No unused code
- [ ] No magic numbers/strings
- [ ] Types model the domain
- [ ] Errors handled with Result, not panics

SECURITY-SCAN:
- Command injection? (string concat to shell)
- Path traversal? (user input in file paths)
- Unsafe deserialization? (trust boundaries)

FIND FLAWS, NOT EXCUSES. If you pass bad code, it's YOUR fault.

LEARNINGS (50w max): What should future AIs know about this code?

OUT:#V{"s":"p","m":true,"v":[{"c":"criterion","m":true,"e":"file:line"}],"cf":0.95,"cupid":[C,U,P,I,D],"l":"learnings"}|{"s":"f","m":false,"v":[{"c":"flaw","m":false,"e":"evidence"}],"cf":0.3,"cupid":[C,U,P,I,D],"l":"what-to-fix"}
EOF
}

#---------------------------------------------------------------------------
# AI Session Runners
#---------------------------------------------------------------------------

run_auditor() {
    local iteration="$1"
    local last_result="$2"
    local prompt
    local todo_context

    show_tdd_cycle "red"
    log_auditor "Writing failing test (Iteration $iteration)"
    draw_dashboard "$iteration"

    lock_src
    unlock_tests

    # Feed checklist context to auditor (MUNGER PATCH 1)
    todo_context=$(get_todo_context)
    prompt=$(auditor_prompt "$iteration" "$last_result" "$todo_context")

    log_info "Invoking auditor AI (new session, sonnet-4.5)..."
    AUDITOR_SESSION_ID=$(uuidgen)
    auditor_output=$(claude -p \
        --model sonnet \
        --session-id "$AUDITOR_SESSION_ID" \
        --allowedTools "Read Write Edit Glob Grep Bash(gleam:*) Skill" \
        --append-system-prompt "You are the AUDITOR. You may ONLY modify files in test/. Any attempt to modify src/ will fail. Focus on writing ONE failing test that drives good design. If all requirements are met, output REQUIREMENTS_COMPLETE. IMPORTANT: Use /gleam-code-generator skill for all Gleam code generation." \
        "/gleam-code-generator $prompt" 2>&1 </dev/null)

    echo "$auditor_output"

    # Save auditor's reasoning to history for implementer
    LAST_AUDITOR_REASONING="$auditor_output"
    append_history "AUDITOR" "$iteration" "$auditor_output"

    lock_tests

    if echo "$auditor_output" | grep -q "REQUIREMENTS_COMPLETE"; then
        log_success "Auditor reports all requirements are complete!"
        return 1
    fi

    log_success "Auditor phase complete"
    return 0
}

run_implementer() {
    local test_output="$1"
    local iteration="$2"
    local attempt=1

    show_tdd_cycle "green"
    log_implementer "Making test pass (Iteration $iteration)"
    draw_dashboard "$iteration"

    # Load AI learnings
    local ai_learnings
    ai_learnings=$(load_ai_learnings)

    # Determine if we should escalate to Opus
    local use_escalation=false
    local model="sonnet"
    if [ $CONSECUTIVE_FAILURES -ge $ESCALATION_THRESHOLD ]; then
        use_escalation=true
        model="opus"
        log_warning "Escalating to Opus model after $CONSECUTIVE_FAILURES consecutive failures"
    fi

    while [ $attempt -le $MAX_IMPL_ATTEMPTS ]; do
        log_info "Implementation attempt $attempt of $MAX_IMPL_ATTEMPTS $(draw_progress $attempt $MAX_IMPL_ATTEMPTS)"

        lock_tests
        unlock_src

        log_tcr "Recording pre-implementation state..."

        # Pass auditor's reasoning and AI learnings to implementer
        prompt=$(implementer_prompt "$test_output" "$attempt" "$LAST_AUDITOR_REASONING" "$ai_learnings" "$use_escalation")

        log_info "Invoking implementer AI (new session, $model)..."
        IMPLEMENTER_SESSION_ID=$(uuidgen)
        impl_output=$(claude -p \
            --model "$model" \
            --session-id "$IMPLEMENTER_SESSION_ID" \
            --allowedTools "Read Write Edit Glob Grep Bash(gleam:*) Skill" \
            --append-system-prompt "You are the IMPLEMENTER under TCR discipline. You may ONLY modify files in src/. If tests fail, your changes will be REVERTED. Write MINIMUM code to pass the test. IMPORTANT: Use /gleam-code-generator skill for all Gleam code generation." \
            "/gleam-code-generator $prompt" 2>&1 </dev/null)

        echo "$impl_output"

        # Save implementer's reasoning to history
        append_history "IMPLEMENTER" "$iteration (attempt $attempt)" "$impl_output"

        lock_src

        log_phase "TCR HARD GATES"
        log_info "Running HARD GATES (compile + test) to determine commit or revert..."

        # HARD GATES: Compiler and tests - no AI judgment, just pass/fail
        if hard_gate_all; then
            tcr_commit "$iteration" "Implemented for iteration $iteration"
            log_success "HARD GATES PASS! Implementation committed."
            SUCCESSFUL_IMPLS=$((SUCCESSFUL_IMPLS + 1))
            CONSECUTIVE_FAILURES=0  # Reset failure counter on success

            # Update todo checklist with successful implementation (MUNGER PATCH 1)
            if [ -f "$TODO_FILE" ]; then
                log_info "Updating todo checklist..."
                # Mark first unchecked item as checked
                sed -i '0,/- \[ \]/s/- \[ \]/- [x]/' "$TODO_FILE" 2>/dev/null || true
            fi

            return 0
        else
            tcr_revert "$iteration"
            # Provide both compile and test errors for context
            if [ -n "${LAST_COMPILE_ERROR:-}" ]; then
                append_history "TCR" "$iteration" "REVERTED - compilation failed: $LAST_COMPILE_ERROR"
                test_output="COMPILE ERROR: $LAST_COMPILE_ERROR"
            else
                append_history "TCR" "$iteration" "REVERTED - tests failed"
                test_output="$LAST_TEST_OUTPUT"
            fi
            attempt=$((attempt + 1))
            CONSECUTIVE_FAILURES=$((CONSECUTIVE_FAILURES + 1))
            LAST_COMPILE_ERROR=""  # Reset for next attempt

            if [ $attempt -le $MAX_IMPL_ATTEMPTS ]; then
                log_warning "Trying again with fresh implementation..."
            fi
        fi
    done

    log_error "Implementer failed after $MAX_IMPL_ATTEMPTS attempts (all reverted)"
    return 1
}

run_architect() {
    local iteration="$1"

    show_tdd_cycle "refactor"
    log_architect "REFACTOR PHASE (after $SUCCESSFUL_IMPLS green cycles)"
    draw_dashboard "$iteration"

    unlock_all

    # Get session history and AI learnings for architect context
    local session_history ai_learnings
    session_history=$(get_recent_history 200)
    ai_learnings=$(load_ai_learnings)

    prompt=$(architect_prompt "$iteration" "$session_history" "$ai_learnings")

    log_info "Invoking architect AI (new session, sonnet for deeper analysis)..."
    ARCHITECT_SESSION_ID=$(uuidgen)
    architect_output=$(claude -p \
        --model sonnet \
        --session-id "$ARCHITECT_SESSION_ID" \
        --allowedTools "Read Write Edit Glob Grep Bash(gleam:*) Skill" \
        --append-system-prompt "You are the ARCHITECT. You may modify both src/ and test/. Your job is to REFACTOR the code for quality and maintainability. ALL TESTS MUST STILL PASS. Focus on CUPID, code minimization, and idiomatic patterns. Every line must earn its place. SCAN for code smells and CREATE_BEAD for issues you find. IMPORTANT: Use /gleam-code-generator skill for all Gleam code generation." \
        "/gleam-code-generator $prompt" 2>&1 </dev/null)

    echo "$architect_output"

    # Parse architect output for bead creation requests
    log_info "Scanning architect output for code smell beads..."
    parse_and_create_beads "$architect_output"

    # Save architect's reasoning to history
    append_history "ARCHITECT" "$iteration" "$architect_output"

    log_info "Running HARD GATES on architect changes..."
    if hard_gate_all; then
        log_success "Architect refactoring complete - HARD GATES PASS"
        git add -A
        git commit -m "REFACTOR(architect-$REFACTOR_COUNT): Architectural improvements" --no-verify 2>/dev/null || true
        REFACTOR_COUNT=$((REFACTOR_COUNT + 1))
    else
        log_error "Architect broke HARD GATES! Reverting all changes..."
        git checkout HEAD -- "$SRC_DIR/" "$TEST_DIR/"
        git clean -fd "$SRC_DIR/" "$TEST_DIR/" 2>/dev/null || true
        append_history "ARCHITECT" "$iteration" "REVERTED - HARD GATES failed after refactoring"
        log_warning "Architect changes reverted - compile+tests must pass with no warnings"
    fi

    lock_all
}

REVIEWER_VERDICT=""
REVIEWER_OUTPUT=""

run_reviewer() {
    log_reviewer "Final Production Polish"
    draw_dashboard "FINAL"

    unlock_all

    prompt=$(reviewer_prompt)

    log_info "Invoking reviewer AI (new session, sonnet-4.5)..."
    REVIEWER_SESSION_ID=$(uuidgen)
    REVIEWER_OUTPUT=$(claude -p \
        --model sonnet \
        --session-id "$REVIEWER_SESSION_ID" \
        --allowedTools "Read Write Edit Glob Grep Bash(gleam:*) Skill" \
        --append-system-prompt "You are the REVIEWER doing final review. You may modify both src/ and test/. All tests MUST pass. Focus on production readiness and polish. You MUST output ACCEPTANCE_CRITERIA_MET: true or ACCEPTANCE_CRITERIA_MET: false in your response. IMPORTANT: Use /gleam-code-generator skill for all Gleam code generation." \
        "/gleam-code-generator $prompt" 2>&1 </dev/null)

    echo "$REVIEWER_OUTPUT"

    # Extract acceptance criteria verdict
    if echo "$REVIEWER_OUTPUT" | grep -q "ACCEPTANCE_CRITERIA_MET: true"; then
        REVIEWER_VERDICT="passed"
        log_success "Reviewer confirms: ACCEPTANCE CRITERIA MET"
    elif echo "$REVIEWER_OUTPUT" | grep -q "ACCEPTANCE_CRITERIA_MET: false"; then
        REVIEWER_VERDICT="failed"
        log_error "Reviewer reports: ACCEPTANCE CRITERIA NOT MET"
    else
        REVIEWER_VERDICT="unknown"
        log_warning "Reviewer did not clearly state acceptance criteria verdict"
    fi

    # Save AI learnings if present
    if echo "$REVIEWER_OUTPUT" | grep -q "## AI LEARNINGS"; then
        log_info "Saving AI learnings for future sessions..."
        local learnings_content
        learnings_content=$(echo "$REVIEWER_OUTPUT" | sed -n '/## AI LEARNINGS/,/^## /p' | head -n -1)
        save_ai_learning "$learnings_content"
        log_success "AI learnings saved to $AI_LEARNING_FILE"
    fi

    log_info "Running HARD GATES on reviewer changes..."
    if hard_gate_all; then
        log_success "Final review complete - HARD GATES PASS"
        git add -A
        git commit -m "REVIEW: Final polish and review" --no-verify 2>/dev/null || true
    else
        log_error "Reviewer broke HARD GATES! Reverting..."
        git checkout HEAD -- "$SRC_DIR/" "$TEST_DIR/"
        log_warning "Reviewer changes reverted - compile+tests must pass with no warnings"
    fi

    lock_all
}

#---------------------------------------------------------------------------
# Main Loop
#---------------------------------------------------------------------------

# Show usage help
show_usage() {
    echo "Usage: ./tdd-tcr-refactor-loop \"Feature requirements\""
    echo "       ./tdd-tcr-refactor-loop --bead <bead-id>"
    echo "       ./tdd-tcr-refactor-loop -b <bead-id>"
    echo "       ./tdd-tcr-refactor-loop --all"
    echo "       ./tdd-tcr-refactor-loop -a"
    echo ""
    echo "Examples:"
    echo "  ./tdd-tcr-refactor-loop \"Add a function to validate email addresses\""
    echo "  ./tdd-tcr-refactor-loop --bead factory-gleam-00s"
    echo "  ./tdd-tcr-refactor-loop --all    # Process ALL open beads by priority"
    echo ""
    echo "This script enforces full Red-Green-Refactor TDD:"
    echo "  - RED:     Auditor writes failing test"
    echo "  - GREEN:   Implementer makes it pass (TCR enforced)"
    echo "  - REFACTOR: Architect improves design every $REFACTOR_INTERVAL cycles"
    echo "  - REVIEW:  Final polish at the end"
    echo ""
    echo "Bead mode automatically:"
    echo "  - Updates bead status to 'in_progress' when starting"
    echo "  - Updates bead status to 'closed' on success"
    echo "  - Updates bead status to 'failed' on failure"
    echo ""
    echo "Tooling integration (auto-detected):"
    echo "  - bv: Graph-aware triage (PageRank, blockers, critical path)"
    echo "  - bd: Bead updates and status management"
    echo "  - codanna: Semantic code search (if initialized)"
    echo "  - Falls back to direct .beads/*.jsonl manipulation"
    echo ""
    echo "Configuration:"
    echo "  - PAUSE_BETWEEN_BEADS=${PAUSE_BETWEEN_BEADS}s (in --all mode)"
    echo "  - REFACTOR_INTERVAL=${REFACTOR_INTERVAL} (architect runs every N green cycles)"
    echo "  - MAX_ITERATIONS=${MAX_ITERATIONS} (max TDD cycles per bead)"
    exit 1
}

# Show all-beads summary banner
show_all_beads_banner() {
    local total_beads="$1"

    clear
    echo ""
    echo -e "${MAGENTA}"
    echo '  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó'
    echo '  ‚ïë                                                                    ‚ïë'
    echo '  ‚ïë      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ïó         ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ïë'
    echo '  ‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë         ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó  ‚ïë'
    echo '  ‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë         ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë  ‚ïë'
    echo '  ‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë         ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë  ‚ïë'
    echo '  ‚ïë     ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù  ‚ïë'
    echo '  ‚ïë     ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïë'
    echo '  ‚ïë                                                                    ‚ïë'
    echo '  ‚ïë              Processing ALL Open Beads by Priority                 ‚ïë'
    echo '  ‚ïë                                                                    ‚ïë'
    echo '  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù'
    echo -e "${NC}"
    echo ""
    echo -e "  ${CYAN}Total open beads:${NC} ${BOLD}$total_beads${NC}"
    echo -e "  ${CYAN}Processing order:${NC} P0 (Critical) ‚Üí P1 (High) ‚Üí P2 (Medium) ‚Üí P3 (Low)"
    echo ""
    echo -e "${DIM}$(draw_line '‚îÄ')${NC}"
    echo ""
}

# Show final summary of all beads processed
show_all_beads_summary() {
    echo ""
    echo -e "${CYAN}"
    echo '  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó'
    echo '  ‚ïë                                                                    ‚ïë'
    echo '  ‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ïë'
    echo '  ‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù‚ïë'
    echo '  ‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ïë'
    echo '  ‚ïë     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó  ‚ïö‚ñà‚ñà‚ïî‚ïù  ‚ïë'
    echo '  ‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ïë'
    echo '  ‚ïë     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïë'
    echo '  ‚ïë                                                                    ‚ïë'
    echo '  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù'
    echo -e "${NC}"
    echo ""
    echo -e "${DIM}$(draw_line '‚îÄ')${NC}"
    echo -e "  ${BOLD}üìä ALL BEADS PROCESSING COMPLETE${NC}"
    echo -e "${DIM}$(draw_line '‚îÄ')${NC}"
    echo ""

    echo -e "  ${GREEN}‚úì COMPLETED (${#COMPLETED_BEADS[@]}):${NC}"
    if [ ${#COMPLETED_BEADS[@]} -gt 0 ]; then
        for bead in "${COMPLETED_BEADS[@]}"; do
            echo -e "    ${GREEN}‚Ä¢${NC} $bead"
        done
    else
        echo -e "    ${DIM}(none)${NC}"
    fi
    echo ""

    echo -e "  ${RED}‚úó FAILED (${#FAILED_BEADS[@]}):${NC}"
    if [ ${#FAILED_BEADS[@]} -gt 0 ]; then
        for bead in "${FAILED_BEADS[@]}"; do
            echo -e "    ${RED}‚Ä¢${NC} $bead"
        done
    else
        echo -e "    ${DIM}(none)${NC}"
    fi
    echo ""

    echo -e "  ${YELLOW}‚óã SKIPPED (${#SKIPPED_BEADS[@]}):${NC}"
    if [ ${#SKIPPED_BEADS[@]} -gt 0 ]; then
        for bead in "${SKIPPED_BEADS[@]}"; do
            echo -e "    ${YELLOW}‚Ä¢${NC} $bead"
        done
    else
        echo -e "    ${DIM}(none)${NC}"
    fi
    echo ""
    echo -e "${DIM}$(draw_line '‚îÄ')${NC}"
}

# Process a single bead - returns 0 on success, 1 on failure
process_single_bead() {
    # Mark bead as in_progress when starting
    log_info "Marking bead '$CURRENT_BEAD_ID' as in_progress..."
    update_bead_status "$CURRENT_BEAD_ID" "in_progress"

    # Fancy startup banner
    clear
    echo ""
    echo -e "${CYAN}"
    echo '  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó'
    echo '  ‚ïë                                                                    ‚ïë'
    echo '  ‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó            ‚ïë'
    echo '  ‚ïë   ‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó   ‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó           ‚ïë'
    echo '  ‚ïë      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù           ‚ïë'
    echo '  ‚ïë      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó           ‚ïë'
    echo '  ‚ïë      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù      ‚ñà‚ñà‚ïë   ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë           ‚ïë'
    echo '  ‚ïë      ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù       ‚ïö‚ïê‚ïù    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù           ‚ïë'
    echo '  ‚ïë                                                                    ‚ïë'
    echo '  ‚ïë          ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó        ‚ïë'
    echo '  ‚ïë          ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù        ‚ïë'
    echo '  ‚ïë    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë        ‚ñà‚ñà‚ïë           ‚ïë'
    echo '  ‚ïë    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë        ‚ñà‚ñà‚ïë           ‚ïë'
    echo '  ‚ïë          ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë           ‚ïë'
    echo '  ‚ïë          ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù           ‚ïë'
    echo '  ‚ïë                                                                    ‚ïë'
    echo '  ‚ïë       Adversarial AI-Driven Test-Driven Development               ‚ïë'
    echo '  ‚ïë       with TCR Discipline and Architectural Oversight             ‚ïë'
    echo '  ‚ïë                                                                    ‚ïë'
    echo '  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù'
    echo -e "${NC}"
    echo ""

    # Config summary in a nice box
    echo -e "${DIM}$(draw_line '‚îÄ')${NC}"
    echo -e "  ${BOLD}Configuration${NC}"
    echo -e "${DIM}$(draw_line '‚îÄ')${NC}"
    echo -e "  ${CYAN}Language:${NC}        $PROJECT_LANG"
    echo -e "  ${CYAN}Test Command:${NC}    $TEST_CMD"
    echo -e "  ${CYAN}Source:${NC}          $REQUIREMENTS_SOURCE"
    echo -e "  ${CYAN}Max Iterations:${NC}  $MAX_ITERATIONS"
    if [ "$BEAD_MODE" = true ]; then
        echo -e "  ${MAGENTA}Bead ID:${NC}         $CURRENT_BEAD_ID"
        echo -e "  ${MAGENTA}Bead Title:${NC}      $BEAD_TITLE"
        local priority=$(bead_field "$BEAD_JSON" "priority")
        echo -e "  ${MAGENTA}Priority:${NC}        P$priority"
    fi
    echo -e "${DIM}$(draw_line '‚îÄ')${NC}"
    echo ""

    # Disciplines
    echo -e "  ${RED}‚óè${NC} ${BOLD}RED${NC}       ‚Üí ${YELLOW}üîç Auditor${NC} writes failing test"
    echo -e "  ${GREEN}‚óè${NC} ${BOLD}GREEN${NC}     ‚Üí ${GREEN}üîß Implementer${NC} makes it pass (TCR enforced)"
    echo -e "  ${WHITE}‚óè${NC} ${BOLD}REFACTOR${NC}  ‚Üí ${WHITE}üèõÔ∏è  Architect${NC} cleans up every $REFACTOR_INTERVAL cycles"
    echo -e "  ${MAGENTA}‚óè${NC} ${BOLD}REVIEW${NC}    ‚Üí ${MAGENTA}üìã Reviewer${NC} final polish"
    echo ""

    # TCR reminder
    echo -e "${DIM}$(draw_line '‚îÄ')${NC}"
    echo -e "  ${MAGENTA}‚ü≥ TCR:${NC} ${BOLD}Test && Commit || Revert${NC} - No broken code survives"
    echo -e "  ${CYAN}üì° Context:${NC} Reasoning flows between agents"
    echo -e "${DIM}$(draw_line '‚îÄ')${NC}"
    echo ""

    # Requirements in a box
    draw_box "REQUIREMENTS" "${YELLOW}"
    echo "$REQUIREMENTS" | while IFS= read -r line; do
        echo -e "  ${DIM}‚îÇ${NC} $line"
    done
    echo -e "${DIM}$(draw_line '‚îÄ')${NC}"
    echo ""

    # Initialize AI learning and history systems
    log_info "Initializing AI learning system..."
    init_ai_learning

    # Initialize TODO checklist (MUNGER PATCH 1)
    log_info "Initializing TODO checklist for state tracking..."
    init_todo

    # Initialize history file for context passing between agents
    log_info "Initializing session history for context passing..."
    init_history
    append_history "SESSION START" "0" "Requirements: $REQUIREMENTS"
    append_history "CHECKLIST" "0" "$(get_todo_context)"

    log_info "Ensuring clean git state..."
    git add -A
    git commit -m "PRE-TDD-TCR-REFACTOR: Savepoint before loop" --no-verify 2>/dev/null || true

    lock_all

    local iteration=1
    local last_impl_result=""
    local impls_since_refactor=0

    while true; do
        log_phase "TDD-TCR-REFACTOR ITERATION $iteration"

        # Phase 1: Auditor writes test (RED)
        if ! run_auditor "$iteration" "$last_impl_result"; then
            echo ""
            echo -e "${GREEN}"
            echo '  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó'
            echo '  ‚ïë                                                               ‚ïë'
            echo '  ‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ïë'
            echo '  ‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïë'
            echo '  ‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ïë'
            echo '  ‚ïë   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë  ‚ïë'
            echo '  ‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë  ‚ïë'
            echo '  ‚ïë   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïë'
            echo '  ‚ïë                                                               ‚ïë'
            echo '  ‚ïë         ALL REQUIREMENTS IMPLEMENTED AND TESTED               ‚ïë'
            echo '  ‚ïë                                                               ‚ïë'
            echo '  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù'
            echo -e "${NC}"
            echo ""

            # Final stats box
            echo -e "${DIM}$(draw_line '‚îÄ')${NC}"
            echo -e "  ${BOLD}üìä FINAL STATISTICS${NC}"
            echo -e "${DIM}$(draw_line '‚îÄ')${NC}"
            echo -e "  ${GREEN}‚úì${NC} TCR Commits:         ${GREEN}${BOLD}$TCR_COMMITS${NC}"
            echo -e "  ${RED}‚úó${NC} TCR Reverts:         ${RED}${BOLD}$TCR_REVERTS${NC}"
            echo -e "  ${WHITE}üèõÔ∏è${NC} Architect Refactors: ${WHITE}${BOLD}$REFACTOR_COUNT${NC}"
            echo -e "  ${YELLOW}üîß${NC} Beads Created:       ${YELLOW}${BOLD}$BEADS_CREATED_BY_ARCHITECT${NC}"
            echo -e "  ${CYAN}üìù${NC} Total Iterations:    ${CYAN}${BOLD}$iteration${NC}"
            echo -e "${DIM}$(draw_line '‚îÄ')${NC}"
            echo ""

            # Final architect pass before review
            if [ $impls_since_refactor -gt 0 ]; then
                run_architect "$iteration"
            fi

            # Final review
            run_reviewer

            # Mark bead based on reviewer verdict
            if [ "$BEAD_MODE" = true ]; then
                if [ "$REVIEWER_VERDICT" = "passed" ]; then
                    log_success "Marking bead '$CURRENT_BEAD_ID' as closed (acceptance criteria verified)!"
                    local close_msg="Completed via TDD-TCR-REFACTOR loop. Acceptance criteria verified by reviewer. Commits: $TCR_COMMITS, Reverts: $TCR_REVERTS, Refactors: $REFACTOR_COUNT"
                    update_bead_status "$CURRENT_BEAD_ID" "closed" "$close_msg"
                    COMPLETED_BEADS+=("$CURRENT_BEAD_ID: $BEAD_TITLE")
                elif [ "$REVIEWER_VERDICT" = "failed" ]; then
                    log_error "Marking bead '$CURRENT_BEAD_ID' as failed (acceptance criteria NOT met)"
                    update_bead_status "$CURRENT_BEAD_ID" "failed" "Reviewer determined acceptance criteria were NOT met. Commits: $TCR_COMMITS"
                    FAILED_BEADS+=("$CURRENT_BEAD_ID: $BEAD_TITLE")
                else
                    # Unknown verdict - be conservative, mark as needing review
                    log_warning "Marking bead '$CURRENT_BEAD_ID' as needs_review (verdict unclear)"
                    local close_msg="Completed via TDD-TCR-REFACTOR loop but acceptance criteria verdict unclear. Manual review needed. Commits: $TCR_COMMITS"
                    update_bead_status "$CURRENT_BEAD_ID" "needs_review" "$close_msg"
                    COMPLETED_BEADS+=("$CURRENT_BEAD_ID: $BEAD_TITLE (needs_review)")
                fi
            fi

            unlock_all
            return 0  # Success
        fi

        git add -A
        git commit -m "TEST(tcr-$iteration): New test from auditor" --no-verify 2>/dev/null || true

        log_info "Verifying test is RED (failing)..."

        if run_tests; then
            log_warning "Tests already pass - auditor should write a NEW failing test"
            last_impl_result="All tests passed. Write a new failing test for uncovered requirements."
            iteration=$((iteration + 1))
            continue
        fi

        log_success "Test is RED - proceeding to implementation"

        # Phase 2: Implementer makes it pass (GREEN with TCR)
        if run_implementer "$LAST_TEST_OUTPUT" "$iteration"; then
            last_impl_result="Tests passed and committed. Ready for next test."
            impls_since_refactor=$((impls_since_refactor + 1))

            # Phase 3: Architect refactor check (REFACTOR)
            if [ $impls_since_refactor -ge $REFACTOR_INTERVAL ]; then
                run_architect "$iteration"
                impls_since_refactor=0
            fi
        else
            last_impl_result="Implementation failed after $MAX_IMPL_ATTEMPTS attempts (all reverted). Test may be too ambitious - consider smaller steps."
            log_warning "Continuing despite implementation failure..."

            # MUNGER PATCH 2 & 3: Trigger negotiation on failure (circuit breaker prevents infinite loops)
            log_info "Invoking COUNCIL OF WAR due to implementation failure..."
            if negotiate_contract "$iteration" "$last_impl_result"; then
                log_info "Negotiation succeeded, proceeding with agreed plan"
            else
                log_error "Negotiation failed - forcing emergency fallback test"
            fi
        fi

        iteration=$((iteration + 1))

        if [ $iteration -gt $MAX_ITERATIONS ]; then
            log_phase "MAX ITERATIONS REACHED ($MAX_ITERATIONS)"

            # Final architect pass
            if [ $impls_since_refactor -gt 0 ]; then
                run_architect "$iteration"
            fi

            echo ""
            echo -e "${GREEN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
            echo -e "${GREEN}  FINAL STATISTICS${NC}"
            echo -e "${GREEN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
            echo -e "  TCR Commits:         ${GREEN}$TCR_COMMITS${NC}"
            echo -e "  TCR Reverts:         ${RED}$TCR_REVERTS${NC}"
            echo -e "  Architect Refactors: ${WHITE}$REFACTOR_COUNT${NC}"
            echo -e "  Beads Created:       ${YELLOW}$BEADS_CREATED_BY_ARCHITECT${NC}"
            echo -e "${GREEN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
            echo ""

            # Mark bead as closed (max iterations is still a completion, maybe partial)
            if [ "$BEAD_MODE" = true ]; then
                if [ $TCR_COMMITS -gt 0 ]; then
                    log_success "Marking bead '$CURRENT_BEAD_ID' as closed (max iterations reached)"
                    local close_msg="Partial completion via TDD-TCR-REFACTOR loop (max $MAX_ITERATIONS iterations). Commits: $TCR_COMMITS, Reverts: $TCR_REVERTS"
                    update_bead_status "$CURRENT_BEAD_ID" "closed" "$close_msg"
                    COMPLETED_BEADS+=("$CURRENT_BEAD_ID: $BEAD_TITLE (partial)")
                else
                    log_error "Marking bead '$CURRENT_BEAD_ID' as failed (no successful commits)"
                    update_bead_status "$CURRENT_BEAD_ID" "failed" "No successful commits after $MAX_ITERATIONS iterations"
                    FAILED_BEADS+=("$CURRENT_BEAD_ID: $BEAD_TITLE")
                fi
            fi

            unlock_all
            return 0  # Finished (even if partial)
        fi

        log_info "Automatically continuing to iteration $iteration..."
    done
}

#---------------------------------------------------------------------------
# Main Entry Point
#---------------------------------------------------------------------------

main() {
    check_dependencies

    # Handle --all mode: process all open beads
    if [ "$ALL_BEADS_MODE" = true ]; then
        local bead_ids
        bead_ids=$(get_all_open_beads)
        local total_beads=$(echo "$bead_ids" | grep -c . || echo 0)

        if [ "$total_beads" -eq 0 ]; then
            echo "No open beads found in $BEADS_DIR/"
            exit 0
        fi

        show_all_beads_banner "$total_beads"
        show_bv_triage

        local bead_num=0
        # Use fd 3 to avoid stdin consumption by claude/other commands inside the loop
        while IFS= read -r bead_id <&3; do
            [ -z "$bead_id" ] && continue
            bead_num=$((bead_num + 1))

            echo ""
            echo -e "${MAGENTA}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
            echo -e "${MAGENTA}‚ïë  BEAD ${bead_num}/${total_beads}: ${bead_id}${NC}"
            echo -e "${MAGENTA}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
            echo ""

            # Setup the bead
            if ! setup_bead "$bead_id"; then
                local setup_result=$?
                if [ $setup_result -eq 2 ]; then
                    # Skipped (not open)
                    SKIPPED_BEADS+=("$bead_id: not open")
                else
                    # Error finding bead
                    FAILED_BEADS+=("$bead_id: not found")
                fi
                continue
            fi

            # Process the bead
            if process_single_bead; then
                log_success "Bead '$CURRENT_BEAD_ID' completed!"
            else
                log_error "Bead '$CURRENT_BEAD_ID' failed!"
                FAILED_BEADS+=("$CURRENT_BEAD_ID: $BEAD_TITLE")
            fi

            echo ""
            echo -e "${DIM}$(draw_line '‚îÄ')${NC}"
            echo -e "  ${CYAN}Progress:${NC} $bead_num / $total_beads beads processed"
            echo -e "${DIM}$(draw_line '‚îÄ')${NC}"

            # Pause between beads (except after the last one)
            if [ $bead_num -lt $total_beads ] && [ $PAUSE_BETWEEN_BEADS -gt 0 ]; then
                log_info "Pausing ${PAUSE_BETWEEN_BEADS}s before next bead..."
                sleep $PAUSE_BETWEEN_BEADS
            fi

        done 3<<< "$bead_ids"

        show_all_beads_summary
        exit 0
    fi

    # Handle single bead or requirements mode
    if [ -z "$REQUIREMENTS" ] && [ "$BEAD_MODE" = false ]; then
        show_usage
    fi

    # Single bead or requirements mode
    if [ "$BEAD_MODE" = true ] && [ -n "$CURRENT_BEAD_ID" ]; then
        process_single_bead
        exit $?
    fi

    # Plain requirements mode (original behavior)
    process_single_bead
    exit $?
}

cleanup() {
    local exit_code=$?
    log_info "Cleaning up locks..."
    chmod -R u+w "$SRC_DIR/" 2>/dev/null || true
    chmod -R u+w "$TEST_DIR/" 2>/dev/null || true

    # If bead mode and exiting with error (interrupted or failed), mark bead as failed
    if [ "$BEAD_MODE" = true ] && [ $exit_code -ne 0 ]; then
        log_error "Marking bead '$CURRENT_BEAD_ID' as failed (exit code: $exit_code)"
        update_bead_status "$CURRENT_BEAD_ID" "failed" "Loop terminated with exit code $exit_code. Commits: $TCR_COMMITS, Reverts: $TCR_REVERTS"
    fi

    # Keep history file for debugging, but could add: rm -f "$HISTORY_FILE"
}

trap cleanup EXIT

main
